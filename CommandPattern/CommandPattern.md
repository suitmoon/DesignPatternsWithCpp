# 命令模式
命令模式（Command Pattern）一种行为型设计模式，它将请求（命令）封装成对象，从而使您可以使用不同的请求、排队或记录请求，以及支持可撤消操作。等功能。

命令模式的核心思想是：**将请求的发送者与接收者解耦**，使得请求的发送者不需要知道请求的具体处理方式。

命令模式通常涉及以下几个角色：
- **命令接口**：声明一个执行操作的接口，通常是一个 `execute` 方法。。
- **具体命令**：实现命令接口，封装具体的请求和处理逻辑。具体命令通常持有一个接收者对象的引用，并在 `execute` 方法中调用接收者的方法。
- **接收者**：知道如何实施与执行一个请求相关的操作。
- **调用者**：要求执行命令。

### 命令模式的应用场景
1. **实现撤销和重做功能**：   
    - 当需要实现撤销和重做功能时，可以使用命令模式。        
2. **支持命令的排队和日志记录**：    
    - 当需要支持命令的排队和日志记录时，可以使用命令模式。       
3. **解耦请求的发送者与接收者**：    
    - 当需要解耦请求的发送者与接收者时，可以使用命令模式。


命令模式（Command Pattern）与 C++ 中的函数对象（Function Objects）有一些相似之处。两者都可以将某个操作封装为一个可执行的对象，从而实现对操作的灵活管理和调用。
### 相似点
1. **封装操作**：
    - **命令模式**: 把一个请求封装成一个对象（命令对象），使得您可以使用不同的请求、排队或记录请求，以及支持可撤消操作。
    - **函数对象**: 也是一种封装操作的方式，通过重载 `operator()` 来创建可以像函数一样调用的对象。
2. **可扩展性**：
    - 两者都允许在不修改现有代码的情况下添加新的操作。例如，可以通过创建新的命令对象或新的函数对象来扩展功能。
3. **参数和状态**：
    - 在命令模式中，具体命令类可以带有状态，例如属性和行为（例如具体的接收者）。
    - 函数对象也可以持有状态。它们可以包含成员变量并在调用时使用它们。
### 不同点
1. **目的**：
    - **命令模式**: 主要用于将请求封装为对象，以便于管理请求及其执行，比如撤销和重做操作、命令日志等。
    - **函数对象**: 主要用于提供一种可调用的对象，通常用于 STL 算法（如排序、过滤等）中，允许在算法中传递功能。
2. **接口**：
    - **命令模式**: 通常是通过一个公共接口（如 `Command` 类）来执行操作。
    - **函数对象**: 通过重载 `operator()` 来定义其执行的操作。这使得函数对象可以像普通函数一样使用。
3. **使用场景**：
    - **命令模式**: 更适合于需要解耦请求的发起者和执行者，或者需要实现复杂的命令撤销和调度逻辑的场景。
    - **函数对象**: 更加灵活且易于与 STL 容器和算法结合使用，适合简单的功能实现和一时性的操作。
