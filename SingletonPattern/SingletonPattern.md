# 单例模式
单例模式（Singleton Pattern）属于创建模式，它确保一个类仅有一个实例，并提供一个全局访问点。能避免过多的实例化，节省内存和资源。

单例模式的核心思想是：**控制实例的创建过程，确保在整个应用程序中只有一个实例存在**。


### 单例模式的结构
单例模式通常包含以下几个角色：
1. **Singleton（单例类）**：
    - 负责创建自己的唯一实例，并提供一个全局访问点。
    - 单例类的构造函数通常是私有的，以防止外部代码直接创建实例。
2. **Client（客户端）**：
    - 通过单例类的全局访问点获取单例实例。

示例代码：
	Singleton_1.cpp（饿汉式）
	Singleton_2.cpp （互斥锁懒汉式）
	Singleton_3.cpp（call_once懒汉式）
	Singleton_4.cpp （智能指针懒汉式）

### 单例模式的应用场景
单例模式常用于需要控制资源访问或共享全局状态的场合，比如日志记录、数据库连接、线程池（Qt 的线程池 (`QThreadPool`) 是单例模式）等。
- 需要全局唯一实例。
- 需要节省资源。  
- 需要全局访问点。

### 确保单例在多线程环境下的安全实现：
  1. **懒汉式单例（加锁）**：在第一次访问时创建实例，使用互斥锁（Singleton_2）或者std:call_once（Singleton_3），确保函数或代码片段在多线程环境下，只执行一次来确保线程安全。

  2. **饿汉式单例**：在程序开始时就创建实例，不需处理线程安全问题。唯一的问题是实例的创建会在程序启动时发生，可能会导致资源浪费。如Singleton_1。

  3. **关于智能指针单例：** 单例模式的核心思想是确保类只有一个实例并提供全局访问点。因此，在构造单例时，通常希望控制该实例的生命周期，使其在整个应用程序生命周期内都存在。智能指针会对对象的生命周期进行管理，这可能会与单例模式的目的相悖。
     智能指针，尤其是 std::shared_ptr，由于涉及到引用计数的管理，会引入一定的性能开销。而单例模式通常被用于性能要求较高的场景，这种开销可能不必要。
     单例模式构造和析构私有化，智能指针需要自定义删除器（包括留空lamda）的重载方式std::shared_ptr<Singleton>(new Singleton(), [](Singleton* ptr) {})
     否则会因访问不到私有化的析构函数而报错。





  









